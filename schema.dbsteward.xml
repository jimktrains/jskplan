<?xml version="1.0" encoding="utf-8"?>
<dbsteward>
  <database>
    <role>
      <application>jim</application>
      <owner>jim</owner>
      <replication>jim</replication>
      <readonly>jim</readonly>
    </role>
  </database>
  <schema name="jskplan" owner="ROLE_OWNER">
    <sequence name="sf_table_id_seq" owner="ROLE_OWNER"/>
    <function name="sf_next_id" returns="VOID" owner="ROLE_OWNER">
        <functionParameter type="out text" />
        <functionDefinition language="plpgsql" sqlFormat="pgsql8">
          <![CDATA[
          DECLARE
              our_epoch bigint := 1314220021721;
              seq_id bigint;
              now_millis bigint;
              shard_id int := 5;
              result bigint := 0;
          BEGIN
              -- there is a typo here in the online example, which is corrected here
              SELECT nextval('sf_table_id_seq') % 1024 INTO seq_id;

              SELECT FLOOR(EXTRACT(EPOCH FROM clock_timestamp()) * 1000) INTO now_millis;
              result := (now_millis - our_epoch) << 23;
              result := result | (shard_id << 10);
              result := result | (seq_id);
              resulttxt := encode(int8send(result), 'base64');
              resulttxt := trim(both '=' from resulttxt);
              resulttxt := replace(resulttxt, '+', '-');
              resulttxt := replace(resulttxt, '/', '_');
          END;
          ]]>
        </functionDefinition>
        <grant operation="EXECUTE" role="ROLE_OWNER" />
    </function>
    <function name="new_issue_id" returns="trigger" owner="ROLE_OWNER">
        <functionDefinition language="plpgsql" sqlFormat="pgsql8">
          BEGIN
            IF NEW.issue_id IS NULL THEN
              NEW.issue_id := NEW.parent::ltree || sf_next_id();
          END;
        </functionDefinition>
        <grant operation="EXECUTE" role="ROLE_OWNER" />
    </function>
    <function name="update_old_state" returns="trigger" owner="ROLE_OWNER">
        <functionDefinition language="plpgsql" sqlFormat="pgsql8">
          BEGIN
            IF NEW.issue_id IS NULL THEN
              NEW.issue_id := coalesce(NEW.parent,'')::ltree || sf_next_id();
          END;
        </functionDefinition>
        <grant operation="EXECUTE" role="ROLE_OWNER" />
    </function>
    <trigger name="auto_new_issue_id"
             table="issue"
             when="BEFORE"
             event="INSERT"
             forEach="ROW"
             function="EXECUTE new_issue_id"
             sqlFormat="pgsql8" />
    <function name="update_points" returns="trigger" owner="ROLE_OWNER">
        <functionDefinition language="plpgsql" sqlFormat="pgsql8">
          BEGIN
            UPDATE issue
            SET points = points - OLD.points + NEW.points
            WHERE issue.issue_id @> NEW.issue_id;
          END;
        </functionDefinition>
        <grant operation="EXECUTE" role="ROLE_OWNER" />
    </function>
    <trigger name="auto_update_points"
             table="issue"
             when="AFTER"
             event="INSERT"
             forEach="ROW"
             function="EXECUTE update_points"
             sqlFormat="pgsql8" />

    <table name="issue" primaryKey="issue_id" owner="ROLE_OWNER" >
      <column name="issue_id" type="ltree" />
      <column name="parent" type="ltree" />
      <column name="name" type="text" null="false"/>
      <column name="description" type="text" />
      <column name="current_state" foreignTable="state" foreignColumn="state_id" default="'FxMFsOgAFBU'" />
      <column name="old_state" foreignTable="state" foreignColumn="state_id" default="'FxMFsOgAFBU'" />
      <column name="assignee" foreignTable="member" foreignColumn="member_id" />
      <column name="points" type="decimal(6,1)" default="0.0" null="false" />

      <constraint name="state_transition_fk" type="FOREIGN KEY"
                  definition="(old_state, current_state)" foreignTable="state_transition" />
    </table>
    <table name="state" primaryKey="state_id" owner="ROLE_OWNER">
      <column name="state_id" type="text" default="sf_next_id()" />
      <column name="name" type="text" null="false" />
      <rows columns="state_id, name">
        <row>
          <col>FxMFsOgAFBU</col>
          <col>New</col>
        </row>
        <row>
          <col>FxMFsOgAFBY</col>
          <col>Complete</col>
        </row>
      </rows>
    </table>
    <table name="state_transition" primaryKey="old_state, new_state" owner="ROLE_OWNER">
      <column name="old_state" foreignTable="state" foreignColumn="state_id" null="false" />
      <column name="new_state" foreignTable="state" foreignColumn="state_id" null="false" />
      <rows columns="old_state, new_state">
        <row>
          <col>FxMFsOgAFBU</col>
          <col>FxMFsOgAFBU</col>
        </row>
      </rows>
    </table>

    <table name="tag" primaryKey="tag_id" owner="ROLE_OWNER">
      <column name="tag_id" type="text" default="sf_next_id()" />
      <column name="name" type="text" null="false" />
    </table>

    <table name="issue_tag" primaryKey="issue_id, tag_id" owner="ROLE_OWNER">
      <column name="issue_id" foreignTable="issue" null="false" />
      <column name="tag_id" foreignTable="tag" null="false" />
    </table>

    <table name="member" primaryKey="member_id" owner="ROLE_OWNER">
      <column name="member_id" type="text" default="sf_next_id()" />
      <column name="email" type="text" null="false"/>

      <constraint name="email_has_at" type="check" definition="email ~ '.+@.+'" />
    </table>
  </schema>
</dbsteward>

